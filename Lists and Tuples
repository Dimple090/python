#lists in python
#A built-in data type thatstores set of values
#it can store elements of different types(integer,float,string, etc)
#for example
#marks1=89.5
#marks2=83.9
#marks3=78.43
#marks4=55.6
#marks5=89=5.4
#marks6=56.9
#When the size of our class increases, like if we have 50 or 100 students, creating individual variables for each student becomes impractical. To simplify this and manage our data more effectively, we can use built-in data types.
#for example
marks=[89.2,69.9,84.3,98.2,59.3]
print(marks)#pint
print(type(marks))#data type
print(marks[4])#allowed in python
print(len(marks))#returns length



#note:- In languages like C++ and Java, arrays generally require all elements to be of the same type. However, in Python, lists are much more flexible. Python lists can store elements of different types together. You can have integers, strings, and even other lists in the same list.This flexibility makes Python lists very versatile for various data storage needs.
#example
mixed_list = [1, "hello", 3.14, [2, 3]]  # Different types in one list
print(mixed_list)#print
print(mixed_list[1])#allowed in python
print(type(mixed_list))#data type
print(len(mixed_list))#returns length



#strings:-immutable(not change)
# str="dimple parihar"
# print(str)
# str[4]="e"
#lists:-mutable(change)
student=["dimple",99.3,21,"jammu"]
print(student[0])
student[0]="avni"
print(student)



#note:-The range of indexing in programming languages determines how we can access elements within data structures.In Python, indexing starts at 0. This means the first element is accessed with index 0, the second with index 1, and so on.You can access elements using positive indices or negative indices (which count from the end of the list).
my_list = ["apple", "banana", "cherry"]
# Accessing elements using positive indices
first_fruit = my_list[0]   # "apple"
second_fruit = my_list[1]  # "banana"
# Accessing elements using negative indices
last_fruit = my_list[-1]    # "cherry"
second_last_fruit = my_list[-2]  # "banana"



#List slicing
#similar to string slicing
##slicing:-Accessing parts of a string
#str[starting_idx : ending_idx]#ending idx is not included
marks=[86,75,98,55,83,67]
print(marks[:4])
print(marks[-3:-1])
print(marks[2:4])



#lists methods
#1.append
list=[2,1,3]
print(list.append(4))#adds one element at the end[2,1,3,4](print none)
#In Python, the append() method modifies the list in place and returns None. This means that it adds the specified element to the end of the list, but it does not return the updated list itself.
print(list)
#2.sort
print(list.sort())#sorts in ascending order[1,2,3](print none)
print(list)
#3.sort
print(list.sort(reverse=True))#sorts in decending oder [3,2,1](also return none)
print(list)
#4.reverse
print(list.reverse())#reverse list [3,1,2](also return  none)
print(list)
#5.insert
print(list.insert(1,6))#insert element at index(return  none)
print(list)
#6.remove
print(list.remove(1))#removes first occurence of element
print(list)
#7.pop
print(list.pop(1))#removes element at idx
print(list)



#tuples in python
#a built-in data type that lets us create immutuble sequences of values
#tuples:-immutable
tuple=(2,3,1,5,7)
print(tuple)
print(tuple[2])
print(type(tuple))



#Slicing in tuple
#str[starting_idx : ending_idx]#ending idx is not included
marks=(6,75,98,55,83,67)
print(marks[:4])
print(marks[-3:-1])
print(marks[2:4])



#tuple methods
tup=(2,1,3,1)
#1.index(el)
print(tup.index(3))#returns index of first occurrence 
print(tup)
#2.count(el)
print(tup.count(2))#counts total occurrences
print(tup)
